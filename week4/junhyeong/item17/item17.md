# 변경 가능성을 최소화하라 - item17

불변 클래스 : 인스턴스 내부 값을 수정할 수 없는 클래스

e.g. String, BigInteger, BigDecimal

가변 클래스보다 설계하고 구현하고 사용하기 쉬우며 오류가 생길 여지가 적다.

### 클래스를 불변으로 만드는 다섯 가지 규칙

1. 객체의 상태를 변경하는 메서드를 제공하지 않는다.
2. 클래스를 확장할 수 없도록 한다. e.g. 클래스를 final로 선언

⇒ 생성자를 private or package-private으로 만들고 public 정적 팩터리를 제공하는 것이 더 유연함

1. 모든 필드를 final로 선언한다. 
    - 시스템이 강제하는 수단을 이용해 의도를 드러냄
2. 모든 필드를 private으로 선언한다.
    - 클라이언트가 직접 접근해 수정하는 일을 막는다.
3. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.
    - 클라이언트가 그 객체의 참조를 얻을 수 없도록 하자.

```java
public final class Complex {
    private final double re;
    private final double im;

    public Complex(double re, double im) {
        this.re = re;
        this.im = im;
    }

    public double realPart() {
        return re;
    }

    public double imaginaryPart() {
        return im;
    }

    public Complex plus(Complex c) {
        return new Complex(re + c.re, im + c.im);
    }
		...
}
```

- getter만 있고 setter는 없다.
- 클래스가 final이라 확장할 수 없다.
- 모든 필드가 final로 선언되어 초기화 이후 값이 바뀔 수 없다.
- 모든 필드가 private로 선언되어 외부에서 직접 필드를 볼 수 없다.
- 내부에 가변 컴포넌트가 없음

plus 메서드를 보면 인스턴스 자신을 수정하지 않고 새로운 인스턴스를 반환한다.

( 그래서 메서드 이름이 동사 add 대신에 전치사 plus를 사용해서 구분 )

이는 해당 메서드가 객체의 값을 변경하지 않는다는 사실 강조

### 불변 객체의 장점

1. 스레드에 안전해 동기화 할 필요 없다.
- 동시에 사용해도 절대 훼손되지 않아서

⇒ 안심하고 공유할 수 있다.

1. 불변 객체는 아무리 복사해봐야 원본과 똑같고 그러므로 방어적 복사도 필요없다. 그래서 clone 메서드나 복사 생성자를 제공하지 않는게 좋다
2. 불변 객체는 자유롭게 공유할 수 있음은 물론, 불변 객체끼리는 내부 데이터를 공유할 수 있다.
3. 객체를 만들 때 다른 불변 객체들을 구성요소로 사용하면 이점이 많다. 구조가 복잡하더라도 불변식을 유지하기 수월하다.
4. 불변 객체는 그 자체로 **실패 원자성**을 제공한다. 즉 예외가 발생후에도 그 객체는 여전히 유효한 상태다.

⇒ 메서드가 예외가 발생한 후에도 그 객체는 여전히  메서드 호출 전과 똑같은 유효한 상태여야 한다.

### 불변 객체의 단점

1. 값이 다르면 반드시 독립된 객체로 만들어야한다.

```java
BigInteger moby = ....;
moby = moby.flipBit(0); // 새로운 BigInteger 인스턴스를 생성

BigSet moby = ....; // BigInteger처럼 임의 길이의 비트 순열 표현, 다른점은 가변
moby.flip(0); // 원하는 비트 하나만 상수 시간 안에 바꿔주는 메서드 제공
```

원본과 단지 한 비트만 다른 백만 비트짜리 인스턴스를 생성해야한다.

1. 성능

→ 원하는 객체를 완성하기 까지 단계가 많고 중간 단계에서 만들어진 객체들이 모두 버려진다면 성능 문제가 더 불거진다.

⇒ 가변 동반 클래스 : 이 문제를 대체 하려고 흔히 쓰일 다단계 연산을 기본으로 제공한다.

### 가변 동반 클래스

BigInteger는 BitSieve, MutableBigInteger 등의 가변 동반 클래스를 사용하여 성능을 높인다.

String과 StringBuilder도 이 예시에 해당된다.

### 정리

위에 불변 객체 설계 방법에서 모든 필드가 final이고 어떤 메서드도 그 객체를 수정할 수 없어야 한다는 규칙은 사실 좀 과하다.

성능을 위해서 아래와 같이 완화할 수 있다.

<aside>
💡 어떤 메서드도 객체의 상태 중 외부에 비치는 값을 변경할 수 없다.

</aside>

실제로 어떤 불변 클래스는 계산 비용이 큰 값을, 최초 사용시 계산한 뒤, final이 아닌 필드에 캐시해놓기도 한다.